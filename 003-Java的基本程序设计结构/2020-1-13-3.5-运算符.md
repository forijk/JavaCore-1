1. <kbd>+</kbd>  <kbd>-</kbd> <kbd>*</kbd> <kbd>/</kbd> <kbd>%</kbd>
2. 整数被0除会产生一个异常,而浮点数被0除将会得到无穷大或NaN结果
3. 关键字 **strictfp**标记的方法，必须使用严格的浮点计算来生成可再生的结果
    - 例如:可以把main方法标记为
        ```java
        public static strictfp void main(String[] args)
        ```
    - 也可标记类
    - 在默认情况下，中间结果允许使用扩展的指数，但不允许使用扩展的尾数(Inter芯片在阶段尾数时并不损失性能)，因此，这两种方式的**区别**仅仅在于采用默认的方式不会产生溢出,而采用严格计算有可能产生溢出
    - 这也没什么关系，对于大多数程序员来说，浮点溢出不属于大问题

## 1.数学函数与常量
1. Math类
    - Math.sqrt(x) x的平方根
    - 静态方法   ，  处理的不是对象
    - pow(x,a) x的a次幂 
        - 两个double类型的参数，其返回结果也是double
    - floorMod 
        - 解决一个长期存在的有关整数余数的问题
        ```java
        n % 2; //n为偶数，表达式为0；n为奇数，表达式为1；n为负数，表达式为-1
        // 数学(欧几里得)规则:余数总是要>=0
        // 调整时针的位置
        (position + adjustment) % 12 // 其结果可能为负数，所以还要引入一个分支，或者
        ((position + adjustment) % 12 + 12) % 12
        // 不管怎样，都很麻烦
        floorMod(position + adjustment，12) // 总会得到一个 0 ~ 11 之间的数字
        // 遗憾的是对于负除数会得到负数结果,不过这种情况在实际中很少出现
        ```
    - Math 提供了常用的三角函数
    - Math 提供了指数函数，以及他的反函数----自然对数以及以10为底的对数
        - exp
        - log
        - log10
    - Math提供了pai 和 e 常量 的近似值
        - PI
        - E
    - 引入
        ```java
        import static java.lang.Math.*
        ```
    - 使用StrictMath，确保在所有平台上得到相同的结果

## 2.数值类型之间的转换
    6个 实心箭头转换不会丢失信息，3个虚线箭头不会

 ![数值转换](F:\Java_core\003-Java的基本程序设计结构\数值类型之间的转换.PNG,'数值类型之间的合法转换')

- 两个不同的数值类型进行二元操作时,先要将两个操作数转换成一种类型，然后再进行计算
- 有一个double，就会转换成double
    - 否则，有一个float，另一个转换成float 
    - 否则，有一个long，另一个转换成long
    - 否则，两个都会被转换成int

## 3.强制类型转换
1. 有可能丢失一些信息
2. 语法格式
    ```java
    double x=9.997;
    int nx = (int) x;  // 通过极端小数部分转换为整型nx=9
    ```
3. 如果想对浮点数进行舍入，要使用Math.round
    ```java
    double x=9.997;
    int nx = (int) Math.round(x);  // nx=10
    ```
    - 调用round的时候，仍然需要使用强制类型转换(int)。
    - 其原因是round方法返回的结果为long类型,由于存在信息丢失的可能性，所以只有使用显示的    强制类型转换才能够将long类型转换成int
4. 如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值，例如，(byte) 300 的实际值为44 
5. 不要在boolean类型与任何数值类型之间进行强制类型转换，这样可以防止发生错误，只有极少数的情况才需要将布尔类型转换为数值类型，这时可以使用条件表达式 b ? 1:0

## 4.结合赋值和运算符
1. x += 4
2. 若左右两侧操作数的类型不同，就会发生强制类型转换
    - x += 3.5;
    - 是合法的，将把x设置为(int)(x+3.5)

## 5.自增与自减运算符
1. ```java
    int n = 12;
    n++;  // n = 13 
    ```
2. 指适用于变量，即 4++ 就是不合法的
3. 还有另一种形式，前缀的形式:++n
    - 前缀形式会先完成加1
    - 后缀形式会使用变量原来的值
    ```java
    int m=7;
    int n=7;
    int a = 2 * ++m; now a is 16, m is 8
    int b = 2 * n++; now b is 14, n is 8

## 6.关系和boolean运算符
1. 检测相等性 == 
    - 3 == 7 的值为false
2. 检测不相等 !=
3. <  >  <=  >= 
4. java沿用了C++的做法，使用<kbd>&&</kbd> 表示逻辑 “与” 
5. 使用 <kbd>||</kbd>表示逻辑 “或”
6. <kbd>||</kbd> 和 <kbd>&&</kbd> 按照短路方式来求值，如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。
    - x < y ? x:y  会返回x和y中较小的那一个

## 7.位运算符
1. <kbd>&</kbd>(and)  <kbd>|</kbd>(or)  <kbd>^</kbd>(xor)  <kbd>~</kbd>(not)
2. 和 <kbd>&&</kbd> <kbd>||</kbd> 狠类似， <kbd>&</kbd>(and)  <kbd>|</kbd>运算符不采用“短路”方式来求值,也就是说，得到计算结果之前两个运算符都需要计算
3. <kbd>>></kbd> 和 <kbd><<</kbd> 运算符将位模式左移或右移
    - 需要建立位模式来完成位掩码时，这两个运算符会很方便
4. <kbd>>>></kbd> 运算符会用0填充高位，这与 <kbd>>></kbd> 不同,他会用符号填充高位
5. 不存在 <kbd><<<</kbd>

## 8.括号与运算符级别
1. 由于 <kbd>&&</kbd> 的优先级比 <kbd>||</kbd> 高，所以
    - a && b || c
    等价于
    - (a && b) || c
2. 因为 += 是右结合运算符，所以表达式
    - a += b += c
    等价于
    - a += (b += c)
3. 与 C 或者 C++ 不同，Java不使用逗号运算符。不过可以在for语句的第1和3部分中使用逗号分隔表达式列表
4. 运算符优先级表

![运算符优先级1](F:\Java_core\003-Java的基本程序设计结构\运算符优先级1.PNG,'运算符优先级1')

![运算符优先级2](F:\Java_core\003-Java的基本程序设计结构\运算符优先级2.PNG,'运算符优先级表2')


## 9. 枚举类型
1. 有时候，变量的取值只在一个有限的集合内。**防止变量中编码进了错误的值**
2. ```java
    enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};
    Size s = Size.MEDIUM;
    ```
    - Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null值，null表示这个变量没有设置任何值
3. 第五章介绍详细内容






    

