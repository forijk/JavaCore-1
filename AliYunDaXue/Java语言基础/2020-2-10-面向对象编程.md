# 1.类与对象

## 面向对象简介

1. 面向过程指的是面对于一个问题的解决方案
    * 更多的情况是不会做重用的设计
2. 在面向对象的设计里面，更多的考虑的是标准的模块化设计
    * 在使用的时候，根据标准进行拼装

3. 面向对象的三个主要特征
    1. 封装性: 内部的操作对外部而言不可见
    2. 继承性: 在已有结构的基础上继续进行功能的扩充
    3. 多态性：是在继承性的基础上扩充而来的概念。指的是类型的转换处理
4. 面向对象开发的三个步骤
    1. OOA : 面向对象分析
    2. OOD ：面向对象设计
    3. OOP ：面向对象编程

## 类与对象简介

1. 核心组成: 类与对象
    
    * 类: 一类事物的共性的抽象的概念
    * 对象：一个具体的事物
2. 类是一个模板，而对象才是类可以使用的实例

3. 类的两个组成部分
    * 成员属性(Field)
    * 操作方法(Method)

## 类与对象的定义及使用

1. 产生对象的语法格式
    * 声明 并实例化对象 :类名称 对象名称 = new 类名称()
    * 分步骤完成

        - 声明对象：类名称 对象名称 = null
        - 实例化对象：对象名称 = new 类名称()

2. 操作实例化对象

## 对象内存分析
### 对象实例化操作初步分析
1. Java之中类属于引用数据类型，引用数据类型最大的困难之处在于要进行内存管理，同时在进行操作的时候，也会发生内存关系的变化，所以针对于之前的程序的内存关系进行一些简单的分析
    * 范例：
    ```java

    ```
    * 如果要进行内存分析，那么首先要给出两块最为常用的内存空间
        1. 堆内存：保存的是对象的具体信息
            * 在程序中，堆内存空间的开辟是通过new完成的
        2. 栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，而后找到对象内容；
            * 但是为了分析简化期间，简单的理解为：对象的名称保存在了栈内存之中per(Ox0001)



    * 分析：
        ```java
        Person per = new Person();
        // new 开辟新的堆内存
        // Person() 定义数据信息的内容
        ---> // 内存地址Ox0001保存信息 {name=null，age=0}
        // per 是栈内存中保存的一个名字

        per.name = "张三"
        per.name = 18
        // 堆内存中的数据已经发生改变
        ```

    * 分步骤完成实例化分析

        ```java
        Person per = null;
        // 开了一个栈内存的空间，并没有具体的指向
        per = new Person;
        //开辟堆空间
        ```

2. 调用要在实例化之后
    * 空指向异常

## 对象引用分析

1. 引用传递的本质:同一块堆内存空间可以被不同的栈内存所指向，也可以更换指向

    ```java
    Person per1 = new Person();
    per1.name = "张三";
    per1.age = 18;
    Person per2 = per1; //  这就是引用传递
    //per1和per2是同一块栈内存地址，执行同一个堆内存
    per2.age = 80;
    per1.tell(); // 张三，年龄80
    ```

2. 引用传递可以发生在方法上，这个时候一定要观察方法的参数类型，同时也要观察方法的执行类型
    ```java
    change(Person temp); 
    ```

## 引用与垃圾产生分析
1. 经过了一系列的分析之后已经确认，所有的引用传递的本质就是一场堆内存的调戏游戏。但是对于引用传递，如果处理不当，那么也会造成垃圾的产生。
    ```java
    Person per1 = new Person();
    per1.name = "张三";
    per1.age = 18;
    Person per2 = new Person();
    per2.name = "李四";
    per2.age = 19;
    per2 = per1;
    per2.age = 80;
    per1.tell(); // 张三 80
    ```
    
    * 分析
    ```java
    //per1 和per2 开辟新的堆内存空间

    per2 = per1; //完成引用传递,per2改变了引用，per2原本引用的堆地址就变成了垃圾空间
    per2.age = 80 // 修改的就是per1引用的堆地址的空间的内容
    ```
2. 所谓的垃圾空间指的就是没有任何栈内存所指向的堆内存空间，所有的垃圾都将被GC垃圾回收器，不定期进行回收，并且释放无用内存空间，但是垃圾过多，一定影响到GC的处理性能从而降低整体的程序性能，在实际的开发之中，对于垃圾的产生应该越少越好，

3. 一个栈内存只能够保存一个堆内存的地址数据，如果发生更改，则之前的地址数据将被回收

# 2.深入分析类与对象
## 成员属性封装
1. 采用封装性堆属性进行保护
2. 在默认情况下，对于类中的属性是可以通过其它类利用对象进行调用的， 
    ```java
    class Person {
        String name;
        int age;
        public void tell(){
            System.out.println("姓名: " + name + "年龄: " + age)
        }
    }

    public class JavaDemo {
        public static void main(String[] args) {
            Person per = new Person(); // 声明并实例化对象
            per.name = "张三";  // 在类外部修改属性
            per.age = 18;  // 在类外部修改属性
            per.tell();  // 进行方法的调用
        }
    }
    ```
    * 属性不封装情况下的问题，name和age两个属性，并没有进行封装和处理，这样外部就可以直接进行调用和处理，有可能所设置的是错误的数据，
    * 这个时候就可以用private关键字对属性进行封装处理
    ```java
    class Person {
        private String name; 
        private int age;
        public void tell(){
            System.out.println("姓名: " + name + "年龄: " + age)
        }
    }
    ```
    * 封装之后，对外部不可见，对类的内部是 可见的
    * 为了可以访问封装的属性，则在java开发开发标准中提供有如下要求
        * setter getter 

3. 在以后进行任何类定义的时候一定要记住，类中的所有属性都必须是private封装(98%),


## 构造方法与匿名对象
1. 程序在使用类的时候一般按照了如下的步骤进行:
    1. 声明并实例化对象，这个时候实例化对象中的属性并没有任何的数据存在，都是其对应数据类型的默认值
    2. 需要通过一系列的setter方法为我们类中的 属性设置内容

2. 现在有一个问题，假设类中的属性有很多个（8个），现在就要调用8此setter方法进行内容设置
    * 这样的调用实在是太啰嗦了
    * 考虑到对象初识化的问题，专门提供了构造方法
    * 通过构造方法实现实例化对象中的属性初始化处理
    * 只有在关键字new 的时候使用构造方法，在Java里面构造方法的定义要求如下
        1. 方法名和类名一致
        2. 构造方法无返回值类型
        3. 构造方法是在使用new之后自动调用的
3. 为什么构造方法上不允许设置返回值类型，既然构造方法不会返回数据，为什么不适用void定义呢？
    * 分析:程序编译器是根据代码结构来进行编译处理的，执行的时候也是根据代码结构来处理的
    * 使用了void，编译器会认为这是一个普通方法，普通方法与构造方法最大的区别
4. 既然构造方法本身是一个方法，那么方法就具有重载的特点，
    * 编写重载方法的建议:
        1. 可以按照参数的个数降序或者升序排列

5. 只是通过实例化对象来进行类的操作也是可以的，而这种形式的对象就是匿名对象

```java
new Person("张三", 10).tell();
```
6. 此时已然通过了对象进行了类中tell()方法的调用，但是由于此对象没有任何的引用，因此，会被GC进行会说和释放
7. 什么时候使用匿名对象？

8. 只要是方法都可以传递任意的数据类型(基本数据类型，引用数据类型)

# 3.this关键字

## this调用本类属性

1. this的使用形式上决定了它的灵活性

2. 使用this可以实现以下三类结构的一个描述
    * 当前类的属性
    * 当前类中的方法(普通方法，构造方法):this.方法名称(),this()
    * 描述我们当前前对象

3. 现在我们知道，通过构造方法或者sette方法都可以进行类中的属性的赋值，但是在进行赋值的时候，
    ```java
    class Person {
        private String name;
        provate int age;

        public Person(String n,int a) {
            name = n;
            age = a;
        }
        public void tell {
            ...
        }
        ...
    }
    public class JavaDemo {
        public static void main(String [] args) {
            Person per = new Person("王五",32);
            per.tell();
        }
    }
    ```
    1. 构造参数的问题，构造参数的中的两个参数的目的是为了类中的name或者age属性的初始化，但是现在n和a参数名称不好，不能很好的表示参数的意义
        * 如果将构造方法中的参数名称修改为name和age，则发现无法进行属性的正确设置

        * Java程序中的{}是作为一个结构体的边界符，那么程序里面进行变量，以{}作为一个查找边界，所以，构造方法并没有能够访问类中的属性，
        * 加一个this表示本类属性
            * this.name

    2. 如果说现在讲构造方法

## this调用本类方法
1. 构造方法调用(this())：使用new实例化对象的时候才会调用
2. 普通方法调用(this.方法名称()):实例化对象产生之后就可以调用普通方法
```java
this.setName(name)
setAge(age) //加与不加都表示本类方法。规范的做法是加上
```

3. 实现多个构造方法都要执行一个输出
    目标：没有重复

```java
Person(){
    System.out.println(...);
}

Person(String name){
    this(name); // 调用本类单参构造
    this.age = age;
}

Person(String name,int age){
    this(); // 调用本类无参构造
    this.name = name;
    this.age = age;
}
```

4. 对于本类构造方法的相互调用需要注意一下几点重要问题
    * 构造方法必须在实例化对象的时候调用，所以"this()"的语句只允许放在构造方法的首行
    * 在构造方法中可以调用普通方法，在普通方法中不能调用构造方法
    * 构造方法相互调用时，请保留有程序的出口，别形成死循环

5. 代码的任何位置上都可能有重复的代码，所以消除重复代码时先期学习之中最需要考虑的部分

```java
this("史密斯",null,"财务部",65000)
```


## 综合实战：简单Java类
1. 在以后的开发与设计的过程中，简单的Java类豆浆作为一个重要的组成部分，
2. 所谓的简单Java类指的是可以描述某一类信息的程序类，例如:描述一个人，描述一本书，描述一个部门，描述一个雇员，并且在这个类之中，并没有特别复杂的逻辑操作，只作为一种信息存储的媒介存在。

3. 对于简单Java类而言，其核心的开发结构如下：
    * 类名称一定要有意义，可以明确的描述某一类事务
    * 类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter，getter方法
    * 类之中可以提供无数个构造方法，但是必须要保留有无参构造方法
    * 类之中不允许出现任何输出语句，所有内容的获取必须返回
    * 【非必须】可以提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo()

# 4.static关键字
## 声明static属性
1. static关键字可以用来定义属性和方法
2. 在一个类中，所有的属性一旦定义了，实际上内容都交由各自的堆内存空间保存
    ```java
        private String name
        private int age
        String country = "中华民国"
        ...
    ```
    * 如果定义了3个对象，他们的country属性都是中华民国，一个对象修改属性，只能修改其中的一个对象

    ```java
        private String name
        private int age
        static String country = "中华民国" // 添加static关键字，变成了公共属性
        ...
    ```
    ```java
    Per.country = "中华民国"
    ```
    * 
    这样修改一个对象，所有的对象都会改变

3. static 内存分析
    * 全局数据区: static属性
    * 栈内存
    * 堆内存
4. 所有对象共享一个

5. 但是对于static属性的访问需要注意一点，由于其本身是一个公共的属性，所以可以通过对象进行访问，但是最好的做法应该是通过所有对象的最高代表(类)进行访问。通过类名称直接调用
```java
Person.country = "中华人民共和国" 
```
6. static属性可以在没有实例化对象的时候使用
7. 

## 声明static方法

1. 这个时候对于程序语言方法就有了两种:static方法，非static方法
    * static方法只允许调用static属性或static方法
        * 非要调用可以通过对象调用

            ```java
            new JavaDemo().print();
            ```
    
    * 非static方法允许调用static属性、方法

2. java核心技术一书中的表述是这样的，static方法是没有隐式参数的方法
## static应用案例
1. 范例:编写一个程序类，这个类实现实例化对象个数的统计，每一次创建新的实例化对象，都可以实现一个统计操作
```java
// 这个时候 就可以创建一个static属性，因为所有对象都共享一个static属性，那么在构造方法中可以实现 数据的统计处理
public class javaDemo {
    public static void main(String [] args) {
        new Book("Java");
        new Book("PHP");
        new Book("Python");
    }
}

class Book {
    private String title;
    private static int count = 0;

    public Book(String title) {
        this.title = title;
        count++;
        System.out.println("...")
    }
}
```
2. 范例：实现属性的自动命名处理
```java
public Book(){
    //this.title = "NOTITLE" + count++;
    this("NoTitle"+count++)
}
```

# 5.代码块

1. 在程序中使用{}定义的结构就叫做代码块

2. 按照代码出现的额位置以及定义的方法，分为
    * 普通代码块
    * 构造块
    * 构造块
    * 同步块：多线程

## 普通代码块
1. 一个方法中的代码块
```java
... x = 1000
public static void main(String args[]){
    if (true) {
        int x = 10;
        System.out.println("x = " + x);
    }
    int x = 100;
    System.out.println("x = "+ x);
}
```
2. java规范，相同名称的变量是不能够在同一个方法中存在的，但是由于此时有不同的分界描述, 

3. 如果要定义普通代码块，只需要将当前的if语句取消即可
```java
{
    int x = 10;
    System.out.println("x = " + x)
}
```
4. 可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的 互相影响

## 构造代码块
1. 定义在一个类中的，
```java
class Person(){
    public Person(){
        System.out.println("构造方法")
    }
    {
        System.out.println("构造快")
    }
}
```
2. 构造块会优先于构造方法执行，每一次实例化新对象的时候都会调用构造快中的代码 
## 静态代码块
```java
class Person(){
    public Person(){
        System.out.println("构造方法")
    }
    static {
        System.out.println("静态块")
    }
    {
        System.out.println("构造快")
    }
}
```
1. 静态代码块会优先于构造块执行，并且不管有多少个实例化对象出现，静态代码块只出现一次

2. 静态代码块的主要作用是为类中的静态属性初始化
    * 适用于初始化会有多行代码
    * 优先主方法先执行


# 6.面向对象案例分析
## 案例分析1(Address)
## 案例分析2(Employee)
## 案例分析3(Dog)
## 案例分析4(Account)
## 案例分析5(User)
## 案例分析6(Book)

# 7.数组的定义与使用
## 数组的基本定义13:23
1. 如果说现在要定义100个整型变量，传统的做法
```java
int i1,i2,i3...i100;
int[] numbers = new int[100] 
```
2. 数组的定义格式
    * 数组的动态初始化,初始化之后数组的每一个元素的保存内容为其对应数据类型的默认值
        数组类型 数组名称 [] = new 数据类型[长度]
        数组类型 [] 数组名称  = new 数据类型[长度]
    * 数组的静态初始化，在数组定义的时候，就设置了里面的内容
        数据类型 数组名称 [] = new 数据类型[] {数据1，数据2，数据3}
        数据类型 数组名称 [] = {数据1，数据2，数据3}

3. 循环和length

## 数组引用传递分析09:24
1. 内存关系匹配的问题
2. 数组也是引用数据类型，一定会发生引用传递
3. 由于数组属于引用类型，所以一定要是为其开辟内存空间后才可以使用。如果现在使用了为开辟的 堆内存 空间的数组 则一定会出现"NullPointerException"异常 

## foreach输出04:30
1. 对于数组而言，我们一定会使用for循环
2. 在1.5之后，为了减轻鞋标堆程序的影响(越界)，引入增强型的for循环-foreach
    * for (数据类型 变量:数组|集合) {}

## 二维数组11:20
1. 二维数组定义语法
    * 数组的动态初始化
        数据类型 数组名称 [][] = new 数据类型 [行个数][列个数]
    * 数组的静态初始化
        数据类型 数组名称 [][] = new 数据类型 [][] {{数据},{数据}}
    


## 数组与方法21:28
1. 对于引用数据类型而言，主要的特点是可以与方法进行引用传递，而数组本身也属于引用类型，所以自然也能通过我们的方法实现引用传递的操作。
2. 数组求和、求平均值、求最大、最小值
    * 主类的作用
        只关心如何操作，而具体的操作过程被类进行包装了
    * 数组工具类
        * 初始化中计算


## 数组排序案例分析14:03
1. 排序分析，冒泡排序,见code\JavaSort.java
```java
public class JavaSort {
    public static void main(String[] args){
        int[] arr = new int[] {9,5,4,3,6,7,2,1,10,7,0}
        for (int i = 0;i< arr.length-1,i++){
            for (int j = 0;j < arr.length-i-1;j++){
                if (arr[j] < arr[j+1]){
                    int temp = arr[j+1]
                    arr[j+1] = arr[j]
                    temp = arr[j+1]
                }
            }
        }
        }
    }
}
```
2. 优化：添加Array类，给类添加静态方法，不用实例化就调用
    * 在以后进行类设计的时候，如果发现类中没有属性存在的意义，那么我们定义的方法就没有必要使用普通方法了，因为普通方法需要在有实例化对象产生的时候才能调用


## 数组转置案例分析16:32
1. 数组反转操作指的是进行前后转置处理，即首位交换
2. 两种方法
    * 定义一个新的数组，而后按照逆序的方式保存
        * 画图
        * 编码
        * 内存分析:产生垃圾未代价
    * 在一个数组上转置
        * 画图
            * 换和不换的流程分析
            * 如果要想实现这种转置最需要确定的就是数组转换的次数
            * 次数 = 数组的长度 / 2
            * 实际并不需要去考虑数组时奇数还是偶数
        * 编码
    * 比较两种
        * 第一种循环次数较多还会产生垃圾
        * 第二种循环次数较低，存在if判断，增加了时间 复杂度，可是可以减少无用对象的产生，以提升性能
    
## 数组相关类库08:44
1. 数组排序：java.util.Arrays.sort(数组名称)
2. 数组拷贝: 
    * System.arraycopy(源数组,源数组开始点，目标数组，目标数组开始点，拷贝长度)

## 方法可变参数05:32
1. 实现多个整型的相加
2. 普通的做法就是操作数组
```java
public static int sum(int[] arr){...}
``` 
3. 但这是不符合要求的
4. 1.5之后可以实现多参数，用三个点
    ```java
    public static int sum(int ... data){...}
    ``` 
    * 本质：变种的数组
5.  

## 对象数组
1. 在之前所接触到的都是基本数据类型定义的数组，但是在Java程序本身各种数据都可以成为数组类型，所以类也可以成为数组类型，这样的数组就称为对象数组

2. 定义
    * 动态初始化
    * 静态初始化

3. 内存分析
    * 引用中嵌套引用
4. 对象数组的缺陷：长度是固定的
5. 优势:数据线性保存，根据索引访问，速度较快。时间复杂度是1
# 8.引用传递实际应用

## 类关联结构10:31
1. 引用分析1
    * 一个人可以有一辆汽车
    * 人有车，车属于人

## 自身关联09:05
1. 人的孩子。孩子也是人

## 合成设计模式05:05
1. 电脑的组成
2. 都是通过拆分，然后再组合，通过引用传递组合在一起

# 9.数据表与简单Java类映射转换
## 实战：数据表与简单Java类映射转换18:01


## 实战：一对多映射05:08

## 实战：多对多映射08:22

## 实战：复杂多对多映射16:46

# 10.String类特点分析
## String类简介10:58
1. Java利用JVM的支持制造了一种可以简单实用的String类
2. String类之所以可以保存字符串，主要的原因是其中定义了一个数组，也就是说,在String里面所有的字符串中的每一个字符的数据都是保存在了数组之中
3. 观察源代码实现
    ```java
    // 在1.8之前
    private final byte[] value;
    //在1.9之后
    private final char value [];
    ```
4. 无法改变
5. 除了直接赋值的形式为对象实例化，也可以按照传统的方式李艳构造方法进行实例化的处理
    * 利用构造方法进行实例化 
    ```java
    String str = new String("www.mldn.com")
    ```

## 字符串比较06:14
1. String的相等也可以使用"==",知识判断的不准确而已
    ```java
    String strA = "mldn"
    Srting strB = new String("mldn")
    strA == strB //false
    ```

2. 使用string类提供的一个方法
```java
public boolean equals(String str)

strA.equals(strB) 
```

3. "==" 和equals()的区别
    * == ：进行的是数值比较，如果用于对象比较上比较的是两个内存的地址数值
    * equals ：是类所提供的一个比较方法，可以直接进行字符串内容的判断


## 字符串常量08:07
1. 字符串是将一个匿名对象设置一个具体的引用
2. 此时发现字符串常量已经可以明确的调用equals()方法实现对象的相等判断
3. 字符串中没有字符串常量这种基本类型，有的只是String类的匿名对象
4. 关于对象相等的技巧，将字符串的常量写在前面
    ```java
    String input = null // 接收用户输入，
    "mldn".equals(input)
    input.equals("mldn") //会报错，空对象NullPointerException
    ```
## String类对象两种实例化方式比较26:47
1. 两种处理模式使用哪一种会更好
### 分析直接赋值的对象实例化模式
1. 内存分析
```java
strA = "mldn"
strB = "mldn"
strA.equals(strB)
```
2. 在Java底层里面提供一个专门的字符串池(字符串数组)
    * 在定义了 "mldn" 之后，
    * 在池空间中添加了"mldn"
    * 实际上strA栈内存指向了池空间中的该字符串
3. 采用直接赋值的处理过程，对于字符串而言，可以实现池数据的自动保存，如果再有相同对象定义时，可以减少对象的产生，以提升我们的性能 

### 分析构造方法实例化
1. 内存分析
    ```java
    String str =new String("mldn")
    ```
    * "mldn" 开辟了一个内存空间(匿名对象开辟)
    * new 开辟 空间 (str指向 )
    * 匿名对象的空间编程了垃圾空间 
2. 所以直接赋值要比new节省空间 

3. 可以发现构造方法实例化的对象实际上是属于一种自己专用的内存空间，但是在String类里面也提供有帮助开发者实现手工入池的处理情况
    * public String intern()
    * String str = new String("mldn").intern()
    * 即便是构造出来的String类对象的内容也可以实现对象池的统一管理，但是这种做法台啰嗦了

 4. 面试题 请解释String类两种对象实例化方式的区别?
    * 直接赋值 ：只会产生一个实例化对象，并且可以自动保存到对象池之中。以实现该字符串实例的重用
    * 构造方法 ：会产生两个实例化对象，并且不会自动入池，无法实现对象重用，但是可以利用intern()方法手工入池处理


## String对象常量池08:32
1. 对象池的主要目的,实现数据的共享处理
2. 在Java中对象(常量)池实际上可以分为两种
    * 静态常量池：程序(.class)加载的时候回自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配
    * 运行时常量池： 当一个程序加载之后，里面可能会有一些变量，这个时候提供的常量池

3. 程序在加载的时候并不确定info变量是什么
```java
String info = "wldn"
String str = "www."+ info + ".com"
String strA = "www.wldn.com"
String strB = "www."+ "wldn" + ".com"
str == strA // false 
strA == strB // true
```

## 字符串修改分析09:27

1. 字符串 每修改一次 就回产生一次垃圾空间的回收 String对象的指向就要修改一次 这样程序的性能非常的差、
2. String类在以后的开发中不要进行内容的频繁修改


## 主方法组成分析05:08
1. public 描述的是一种访问权限，主方法是一切的开始点 开始点一定是公共的
2. static 程序的执行时通过类名称完成的，所以表示此方法是由类直接调用
3. void  主方法是一切的起点，起点一旦开始就没有返回的可能
4. main 是一个定义好的方法名称
5. String args[] 字符串的数组，可以实现程序启动参数的接收

6. 在程序执行的时候可以设置参数，每一个参数之间用空格分割:
    ```java
    for (String arg:args){
        System.out.println(arg)
    }
    ```
    
    * 但是如果你的参数本身带有空格，则必须使用 " 包装 

# 11.String类常用方法
## JavaDoc文档简介10:24
1. Java在线API地址
    [https://docs.oracle.com/javase/9/docs/api/overview-summary.html] https://docs.oracle.com/javase/9/docs/api/overview-summary.html 百度搜索JavaDoc
2. 在Jdk1.9之前，所有的Java中常用类库都会在JVM启动的时候进行全部的加载，这样的话，性能会有所下降，所以在java1.9开始提供有模块化的设计 ，将一些程序类放在了不同的模块里面，模块里面是包
3. 在模块之中会包含有大量的程序开发包
4. 如果现在想去看String类的相关定义，则可以打开java.lang这个包
5. 以String类的文档进行说明(java.base java.lang String)
    * 类的完整定义
    * 类相关说明信息
    * 成员属性摘要 Field Summary
    * 构造方法概要 Constructor Summary
        * 如果看见有Deprecated，这个方法就不要再用了
    * 方法摘要 Method Summary
6. 文档一般都会有一些假的中文翻译版(自动翻译的)，最好不要用，整个Java开发的文档设计几十上百份，没有中文
7. 或者你可以看看日文的文档
## 字符串与字符10:58
1. 字符串与字符数组的转换
    > 在JDK1.9之前，所有的String都利用了字符数组实现了包装的处理，所以在String类里面是提供有相应的转换处理方法的。这些方法包含有构造方法与普通方法两类

    1. 字符数组变为字符串
        * public String(char[] value)  //构造
        * public String(char[] value, int offset,int count) // 构造
        * public char charAt(int index) 获取制定索引位置的字符 //普通方法
    2. 字符串转换成字符数组 
        * public char[] toCharArray() 将字符串中的数据以字符数组的形式返回  

2. 范例
```java
public class StringDemo {
    public static void main(String args[]){
        String str = "helloworld";
        char[] result =str.toCharArray();//将字符串变为字符数组
        // 变大写
        for (int i=0;i<result.length;i++){
            result[i] -=32; // 大小写相差32
        }
        String newStr = new String(result);
        System.out.println(newStr)  // HELLOWORLD
    }
}
```
3. 范例，判断一个字符串中的数据是否全部由数字所组成
    * 如果要想判断字符串中的每一位最好的做法是将字符串变为字符数组
    * 可以判断每一个字符是否在数字的范围之内
    ```java
    public static boolean isNumber(String str){
        char [] result = str.toCharArray();
        for (int x = 0;x<result.length;x++){
            if (result[x]<'0' || result[x] > '9') {
                return false;
            }
        }
        return true 
    }
    //
    System.out.println(isNumber(str)?"由数字组成":"不是由数字组成")
    ```
4. 在实际开发之中处理中文的时候往往使用char类型，因为其可以包含中文数据
## 字符串与字节04:08
1. 字符串与字节的转换，是为了进行二进制的数据传输，或者进行编码转换
    * public String​(byte[] bytes)
    * public String​(byte[] bytes,int offset,int length)
    * public byte[] getBytes() 将字符串转为字节数组
    * public byte[] getBytes​(String charsetName) throws UnsupportedEncodingException  编码转换

2. 观察字节与字符串的转换
    ```java
        public static void main(String args[]){
            String str = "helloworld";
            char[] result =str.getBytes();//将字符串变为字符数组
            // 变大写
            for (int i=0;i<result.length;i++){
                result[i] -=32; // 大小写相差32
            }
            String newStr = new String(result);
            System.out.println(newStr)  // HELLOWORLD
    ```
3. 与字符唯一的区别是，字节有长度限制(-128~127)
4. 字节中最重要的一个方法，可以进行编码转换

## 字符串比较07:33
1. 最为常用的就是equals方法，但是这个方法是进行大小写区分的
    * public boolean equals​(Object anObject)
    * public boolean equalsIgnoreCase​(String anotherString) //忽略大小写，不区分大小写
    * public int compareTo​(String anotherString) 字符串大小比较
    * public int compareToIgnoreCase​(String str)

## 字符串查找10:43
1. public boolean contains​(CharSequence s) 判断子字符串是否存在  1.5之后才有的功能
2. public int indexOf​(String str) 从头查找指定字符串的位置。找不到返回-1，找到就返回查找内容起始索引值 1.5之前只能用它
3. public int indexOf​(String str,int fromIndex) 从指定位置查找
4. public int lastIndexOf​(String str) 从后往前查找
5. public int lastIndexOf​(String str,int fromIndex)
6. public boolean startsWith​(String prefix) 
7. public boolean startsWith​(String prefix, int toffset) 由指定位置判断是否以指定的字符串开头
8. public boolean endsWith​(String suffix)

## 字符串替换02:36

1. public String replaceAll​(String regex,String replacement) //全部替换 
2. public String replaceFirst​(String regex,String replacement) //替换首个

## 字符串拆分04:40

1. 拆分，以字符串数组的形式返回
2. public String[] split​(String regex) 按照指定的字符串全部拆分
3. public String[] split​(String regex,int limit) 按照指定的字符串拆分为指定个数，后面不拆了

4. 但是在进行拆分的时候有可能会预检拆不了的情况
    * "192.168.1.209"   split(".")
    * 是因为正则表达式的原因
    * 这个时候最简单的理解就是使用双斜线“\\”进行转义
        * split("\\.")

## 字符串截取05:32

1. public String substring​(int beginIndex) 从指定索引截取到结束
2. public String substring​(int beginIndex,int endIndex) 截取指定范围
    * 范例 
    
    ```java
    String str = "mldn-photo-张山.jpg"
    int beginIndex = str.indexOf("-", str.indexOf("photo")) + 1;
    int endIndex = str.lastIndexOf(".");
    System.out.println(str.substring(beginIndex,endIndex))
    ```


## 字符串格式化04:11
1. public static String format​(String format,Object... args) //  
    * 字符串(%s)
    * 字符(%c)
    * 整数(%d)
    * 小数(%f)
2. 
## 其它操作方法11:27
1. public String concat​(String str) 字符串的连接
    * 是运行时的定义，动态定义，非静态定义
    * "www.wlmv" == "www.".concat("wlmv") // false
2. public String intern()  字符串入池保存
3. public boolean isEmpty() 判断是否为空字符串(不是null)
4. public int length() 计算字符串的长度
5. length()与trim()
    * 在输入的时候，你很难保证你输入的数据没有空格，有空格的时候，数据的查找就会出现错误，那么就必须对输入的数据进行处理，使用trim()
6. 数组length没有括号，是属性
7. public String toUpperCase() 转大写
8. public String toLowerCase() 转小写
9. 虽然在Java之中String类已经提供大量的方法了，但是缺少一个首字母大写的方法
    * 利用方法的组合即可

    ```java
    class StringUtil {

        public static String initcap(String str){
            if (str == null || "".equals(str)) {
                return str;
            }
            if (str.length()==1) {
                return str.toUpperCase()
            }
            return str.substring(0,1).toUpperCase() + str.substring(1);
        }
    }
    ```

# 12.继承的定义与使用

## 继承问题引出06:12

1. 继承性的主要特点在于：可以扩充已有类的功能
2. 好的代码：结构性合理、适合于维护、可重用性很高
 

## 继承的实现11:42
0. Person Student
1. extends关键字实现继承
2. 内存关系
    * 堆内存中引用的父类的对象

3. 扩充属性和方法
    * 内存分析
        * 堆内存中存放的是
            * 父类的属性(name/age)
            * 子类的属性(school)

## 子类对象实例化流程13:12
4. 现在已经成功实现了继关系，并且已经发现了继承的主要特点，但是程序之中提供有继承逻辑，那么对于子类对象的实例化定义 是有要求的
    * 在进行子类对象实例化的时候一定要首先实例化好父类对象
    ```java
    class Person {
        public Person(){
            System.out.println("父类实例化");
        }
    }
    class Student extends Person {
        public Student(){
            super();
            System.out.println("子类实例化");
        }

    }
    public class JavaDemo {
        public static void main(String args[]){
            new Student();
        }
    }
    // 执行结果 :即使没有进行父类实例化，也会自动调用父类的构造方法
    //父类实例化
    //子类实例化
    ```
5. 实际上这个时候就相当于子类的构造方法里面隐含了一个"super()"

6. 在子类写不写super都一样
7. 默认也是调用的无参构造，如果父类没有实现无参构造，会报错或者，直接调用有参构造super(name,age)
8. 结论：无论你如何折腾，在实例化子类对象的同时一定会实例化父类对象，目的是为了所有的属性可以进行空间分配。
9. 子类留的出口就是为了调用父类构造
10. super 和 this 不允许同时出现

## 继承定义限制12:37
1. Java之中不允许多重继承，只允许多层继承
    * 理论上不应该超过3层
2. 在进行继承关系定义的时候，实际上子类可以继承父类中所有的操作结构，但是对于私有操作，属于隐式继承，对于所有非私有操作，属于显示继承，
# 13.覆写 
## 方法覆写13:43
1. 优化父类的方法
2. 调用父类的方法super.方法名称()

## 方法覆写限制08:39
1. 被覆写的方法不能够拥有比父类方法更为严格的访问控制权限
2. 已经接触的访问控制权限
    * public >default（不写）>private
    * 父类是default 子类只能使用public或者default
    * 父类使用了public 子类只能使用public
3. 使用private的问题
    * 父类定义了private的方法A，子类也重写了A
    * 调用的时候，调用到了父类的A，没有调用到子类覆写的A
    * 因为父类的private A方法是不可见的name这个方法对于子类而言就相当于一个新定义的方法，与覆写没有任何的关系

4. 在以后实际开发之中，丁阿姨的方法，95%的情况下都是使用public，所以你要覆写的时候，最好也是用public

5. 面试题: Override和Overloding的区别
    1.概念： 方法名称、参数类型及个数、返回值相同   方法名称相同，参数及类型及个数不同
    2. 权限 无权限限制   子类覆写方法不能拥有更严格的控制权限 
    3. 范围 发生在一个类中   发生在继承关系类中
6. overLoading时返回参数是否相同
    * 在进行方法重载的时候，没有对返回类型做出限制，但是应该保持返回类型的一致，才更加方便处理
## 属性覆盖05:16
1. 使用封装 private之后 ，覆写将无意义
2. 面试题：请解释super 与this的区别
    * 
    * 
    * this 可以表示当前对象

## final关键字09:01
1. 使用final实现
    * 定义不能被继承的类
    * 定义不能被覆写的方法和常量
2. final 定义常量，一旦定义，不可修改
3. 常量往往是共享的，利用全局常量的形式来定义
    `public static final ON=1`

# 14.综合案例：继承分析
## 案例分析一（学生类）07:15
1.  建立人Person类和Student类，功能要求如下
    1. Person含有4个私有型数据成员nane、addr、sex、age，分别为字符串型、字符串型、字符型及整型，一个4参数、2参数、无参数构造方法，重写输出方法，用于显示6种属性
2. Student继承Person，增加math、english成绩，一个6参、2参、无参和重写输出方法显示6中属性

## 案例分析二（管理人员与职员）06:36
1. 定义员工类，具有姓名、年龄、性别属性，并具有构造方法和显示数据方法，
2. 定义管理层类，继承员工类，并有自己的属性职务和年薪
3. 定义职员类，继承员工类，并有自己的属性所属部门和月薪

## 案例分析三（字符串统计）11:19
1. 编写程序，统计出字符串“want you to know one thing”中字母n和字母o出现的次数。
    * 转字符数组
## 案例分析四（数组操作）10:55
1. 建立一个可以实现整型数组的操作类Array，而后在里面可以操作的数组的大小由外部决定，而后在Array类里面需要提供有数组的如下处理：
    * 进行数据的增加(如果数据满了则无法增加)、
    * 可以实现数组的容量扩容、
    * 取得数组全部内容
2. 完成之后再次基础上再派生出两个子类
    * 数组排序类 返回的数据必须是排序的结果
    * 数组反转类 可以实现内容的首尾交换

# 15.Annotation注解
## Annotation简介11:31
1. JDK1.5之后提出的一个新的开发技术结构，利用Annotation可以有效的减少程序配置代码，并且可以利用Annotation进行一些结构化的定义
2. 以一种注解的形式实现的程序开发
3. 要先了解程序开发的历史
    * 过程一：服务器地址的改变写在代码中，地址的改变只能通国程序员来修改
    * 过程二：引入配置文件，配置项不多的时候，可以使用
    * 过程三：将配置信息重写会程序里面 ，利用一些特殊的标记与程序代码进行分离，这就是注解的作用
        * 如果全部使用注解开发，难度太高了，所以现在是配置文件+ 注解
4. 本次的几个基本的注解
    * @Override
    * @Deprecated
    * @suppressWarnings

## 准确覆写05:41
1. 开发中经常遇到的问题
    * 虽然要明确的继承一个父类并且进行方法的覆写。但是有可能疏忽忘记编写extends
    * 方法名写错了
    * 程序编译的时候是不会出错的
2. 解决：追加注解
    * @Override写在方法上，明确表示方法是一个覆写的方法 
## 过期声明05:34
1. 软件迭代开发过程中，新的版本不用的，老的版本还要用的的操作
2. 这样的方法就必须要用@Deprecated注解
3. 变异的时候回提示版本过时的信息，但是依然能够调用
## 压制警告04:13
1. 如果不愿意见到像过期声明那类的信息，就可以使用
2. 或者已经明确的知道了错误在哪里 
2. @suppressWarnings写在调用的方法处
    `@suppressWarnings({"deprecation"})`
3. 它做的只是让警告信息不出现，不骚扰你而已

# 16.多态性
1. 多态性是面向对象中的第三大主要特征，多态性是在继承性的基础上扩展出来的概念，也就是说可以实现父子类之间的互相转换处理
## 多态性简介09:31
1. 在Java之中对于多态性有两种实现的模式
    * 方法的多态性
        * 方法的重载
        * 方法的覆写
    * 对象的多态性
        * 对象的向上转型 : 父类 父类示例 = 子类示例
            * 自动完成
        * 对象的向下转型 ：子类 子类示例 = (子类)父类示例
            * 自动完成

2. 在实际编码中，以向上转型为主

## 对象向上转型09:49
1. 向上转型的主要特点在于，可以对参数进行统一的设计。
```java
fun(new DataBaseMessage())
fun(new WebServerMessage())
public static void fun(Message msg){ //不管传递的是哪一个子类都可以接受
    msg.print()  // 如果有覆写方法，一定是覆写后的方法
}
```

2. 但是为什么此时不适用重载来解决当前问题呢？
    * 维护性差
    * 

## 对象向下转型16:49
1. 向下转型主要特点在于需要使用到一些子类自己特殊的定义处理
2. 范例：超人是普通人，遇到外星人入侵，需要向下转换成超人，会飞,会打，会喷火。。。
3. 向下转型不是一件安全的事情
    * 向下转型之前需要向上转型
## instanceof关键字04:26
1. 因为向下转型的不安全性，所以在转换之前要进行判断，判断某个实例是否是某个类的对象，这个就要通过instanceof判断
```java
per instanceof SuperMan
```
# 17.Object类
## Object类的基本概念07:05
1. 所有类默认都继承Object
2. 如果一个程序方法要求接受所有类对象的时候就可以利用Object实现处理。但是有一点需要注意，在Java设计的过程之中对于所有的引用数据类型实际上都可以使用Object类进行接受，包括数组也可以
3. Object 是一个万能的数据类型，它更加适用于进行程序的标准设计

## 取得对象信息05:04
1. toString()
2. 这个方法调用与不调用的效果是一样的，所以在以后的开发之中可以覆写此方法
3. 
## 对象比较14:14
2. 自己定义的不合适
    * 每一个属性都要进行相等判断，所以在外部要调用大量的getter()方法；
    * 对象比较应该是一个类内部所具备的功能，而不应该在外部定义

1. equals 
    * 默认情况下，该方法只是进行了两个对象的地址判断
    * 因此，要想正确实现判断处理，就必须要覆写此方法，并且进行属性判断
3. 范例 
    * 先确定是同类，才能转换 instanceof
    * 是不是null
    * 是同一个地址，直接返回true
# 18.抽象类的定义与使用
## 抽象类基本概念12:18
`publicic abstract String getConnecttInfo(); // 抽象方法`

## 抽象类的相关说明08:07

## 模板设计模式21:15
1. 应用
2. 抽象类最大的好处
    * 对子类方法的统一管理
    * 可以自身提供有一些普通方法，并且这些普通方法可以与抽象方法互相调用

# 19.包装类
## 包装类实现原理分析12:04
1. 对象包装器
2. 包装类的主要功能是针对于基本数据类型的对象转换而实现的，并且随着Jdk的。。。
3. 基本数据类型是类吗？
4. 原理 
```java
class Int {
    private int data; //包装了一个基本数据类型
    public Int(int data) {
        this.data = data;
    }
    public int intValue() {
        return this.data;
    }
}

public class JavaDemo {
    public static void main(String args[]) {
        Int temp = new Int(10);
    }
}
```

4. 包装类一共有两种类型
    * 对象型包装类(Object 直接子类)
    * 数值型包装类(Number 直接子类)
5. Number类是一个抽象类，以后只要看见了Number 都应该明确的表示它是一个数字的概念,这个类定义有如下方法
    * byteValue 获取byte数据
    * shortValue 获取short数据
    * ...6个

## 装箱与拆箱14:15
1. 数据装箱：将基本数据类型保存到包装类之中，一般可以利用构造方法完成
2. 数据拆箱：从包装类中获取基本数据类型
3. 可以发现从JDK1.9之后，对于所有包装类之中提供的构造方法就变为了过期处理，不建议用户再继续使用，这是因为从JDK1.5之后为了方便处理提供了自动的装箱与拆箱操作，多以这种手工的操作基本上没人用了
```java
Integer obj = 10;
int num = obj;
```
4. 使用自动装箱最大的好处是可以实现Object接收基本数据
```java
Object obj = 19.2;
// double自动装箱为Double，向上转型为Object
// Object 不能做运算，不能直接转成基本类型
double num = (Double)obj; //向下转型为包装类，在自动拆箱
```
5. 包装类要注意的问题，关于相等判断上
    * 一定要使用equals完成
    * 使用 == 会错线范围内的错误
        * 128 128
        * 99 99
        * -128 -128
    * 而包装类本省也需要考虑占位的长度，如果超过了1位的内容，那么我们就需要使用equals()比较。如果不超过，使用==
# 20.接口的定义与使用
1. 抽象类与普通类相比最大的优势在于:可以实现对子类覆写方法的控制
2. 但是在抽象类里面可能依然会保留 有一些普通方法 ，而普通方法可能会涉及到一些安全或者隐私的操作问题，那么这样在我们进行开发的过程之中，如果要想对外部隐藏全部的细节，则可以通过接口来进行描述
3. 在学习了分布式开发的时候，才能对这句话有深度的理解
## 接口基本定义28:45
1. 接口可以理解为一个纯粹的抽象类(最原始的定义接口之中  是包含有抽象方法与全局常量的)
2. 因为1.8之后引入Lambda表达式的概念，所以接口的定义也得到了加强，除了抽象方法与全局常量之外，还可以定义我们的普通方法或者静态方法
3. 从设计本身的角度来讲，借口之中的组成还是应该以抽象方法和全局常量为主
4. interface 关键字

```java
public class InnerInterface {

    public static void main(String args[]) {
        
    }
    
}
// 由于类名称与接口名称的定义相同，所以为了区分出接口，接口名称前往往会加入字母I
interface IMessage { //定义一个接口
    public static final String INFO = "www.mldn.com";
    public abstract String getInfo(); 
}
```
5. 因为有abstract，接口是没法产生实例化对象的，接口的使用原则
    * 接口需要被子类实现(implements),一个子类可以实现多个接口
    * 子类(如果不是抽象类)那么一定要覆写接口之中的全部抽象方法
    * 接口对象可以利用子类对象的向上转型进行实例化
6. 范例:定义接口
7. 范例：继承实现多接口
8. 这个弥补是有限的，这个时候就需要考虑一个世纪的情况了，关于对象的转型问题
    * 范例:观察转换 子类对象可以任意的实现父接口的转换
    * 范例:观察Object与接口转换
        * 接口是不允许去继承父类的，所以接口绝对不会是Object的子类
        * 但是 根据之前的分析MessageImp(继承两个接口，同时肯定是继承了Object)，所以接口一定可以通过Object接收
        ```java
        Imessage msg = new MessageImpl() // 接口类 
        Object obj = msg; // 向上转型，接口类向上转型了
        IChannel chan = (Ichannel) obj // 转换成了另一个接口类
        ```
    * Object类可以接收所有的数据类型，包括基本数据类型、类对象、接口对象、数组
9. 接口描述的是一个公共的定义标准，所以在接口之中所欲的抽象方法的访问权限都是public
    * 因此可以省略接口中的public关键字
    ```java
    interface IMessage {
        String INFO = "www.mldn.com";
        String getInfo();
    }
    ```
10. 接口中的abstract 可以省略，抽象类中不允许省略
11. 虽然接口无法继承一个父类，但是一个接口却可以通过extends继承若干个父接口
    * 叫做接口多继承 
12. 范例：实现接口多继承
```java
interface IMessage {
    public abstract String getInfo();
}

interface IChannel {
    public boolean connect()
}

interface IService extends IMessage,IChannel { //接口多继承
    puvlic String service();
}
```

13. 在实际的开发中，接口的使用往往有三个
    * 进行标准设置
    * 表示一种操作的能力
    * 暴露远程方法视图，这个一般都在RPC分布式开发中使用

## 接口定义加强12:44

1. 接口的不当设计，导致的问题   
    * 若接口增加了一个方法，实现这个接口的1008个子类都需要修改
2. 解决办法:往往不会然子类直接实现接口，而是在中间追加一个过渡的抽象的类
    * 抽象类(过渡抽象类)实现
3. 从JDK1.8之后开始，为了解决接口设计的缺陷，所以在接口之中允许开发者定义普通方法
    1. 定义的普通方法必须追加default的声明，但是需要提醒的是，该操作属于挽救功能，如果不是必须的情况下，不应该作为你设计的首选
4. 除了可以追加普通方法之外，接口里面也可以定义static方法，而static方法就可以通过接口直接调用了

5. 如果现在真的可以在接口里面定义普通方法或static方法，那么这个功能就已经可以取代抽象类，但是不应该将这个组成作为接口的主要设计原则。 以后所写的代码还是应该奉行:接口的核心就是抽象方法

## 使用接口定义标准11:21
1. 对于接口而言，在开发之中最为重要的应用就是进行标准的制定，实际上在我们日常生活之中也会听见许多关于接口的名词
    * 如USB接口 、鼠标接口 PCI接口等待，那么这些实际上都是属于我们标准的应用

2. 范例
```java

```
## 工厂设计模式15:09
1. 对于接口而言，已经可以明确的清楚，必须有子类，并且子类可以通过对象的向上转型，来获取接口的实例化对象，但是我们在进行对象实例化的过程之中也可能存在有设计问题

2. 范例:观察下面的程序
    ```java
    public class JavaDemo {

        public static void main(String[] args) {
            IFood food = new Bread();
            food.eat(); //吃
        }
    }

    interface IFood {  //定义一个食物标准
        public void eat(); //吃
    }

    class Bread implements IFood {
        public void eat() {
            System.out.println("吃面包");
        }
    }
    ```
    * 在本程序之中根据接口进行子类的定义，并且利用对象的向上转型进行接口对象实例化的处理
    * 程序的结构设计
        主类(客户端) ----IFood(<<interface>>)---- Bread
    *  IFood  food = new Bread()
    * 客户端需要明确的指导具体的哪一个子类，如果说现在面包吃腻了，需药牛奶了，那么客户端就要做出修改
        ```java
        // 添加子类
        class Milk implements IFood {
            public void eat(){
                System.put.println("喝牛奶");
            }
        }
        // 修改客户端
        IFood food = new Milk();

        ```
3. 所以现在代码出现了耦合的问题，改变了食物，我就需要去修改客户端
4. 工厂模式:
    ```java
    class Factory {
        public static IFood getInstance(String className) {
            if ("bread".equals(className)) {
                return new Bread()
            } else if ("milk".equals(className)) {
                return new Milk()
            }
        }
    }
    // 修改客户端
    IFood food = Factory.getInstance(args[0]);
    //现在可以通过初始化参数进行要使用的子类定义
    java JavaDemo bread
    ```
5. 主类通过Factory关注子类，不直接关注了
    * 日后进行子类扩充的时候只需要修改Factory程序类即可实现

## 代理设计模式11:42(Proxy)
1. 帮助用户将所有的开发注意力只集中在核心业务功能的处理上，例如 
2. 建立代理类继承吃的接口，接收吃的对象，实现吃的方法，用接收的对象去吃
## 抽象类与接口区别07:53
1. 在实际开发之中可以发现抽象类和接口的定义形式是非常相似的，这一点从JDK1.8开始实际上就特别明显了，因为在JDK1.8 里面，接口也可以定义default或者static方法了，但是这两者依然有着明显的定义区别于使用区别

| No | 区别 | 抽象类 | 接口 |
| 1 | 2 | 3 | 4 |
| 1 | 定义 | abstract class 抽象类名称{} | interface 接口名称 {} |
| 2 | 组成 | 构造、普通方法、静态方法、全局常量、普通成员、static方法 | 抽象方法、全局常量、普通方法、static方法 |
| 3 | 权限 | 可以使用各种权限定义 | 只能使用public |
| 4 | 子类使用 | 子类通过extends关键字可以继承一个抽象类 | 子类使用implements关键字可以继承多个接口 |
| 5 | 两者关系 | 抽象类可以实现若干个接口 | 接口不允许继承抽象类，允许继承多个父接口 |
| 6 | 使用 | 1.抽象类或者接口必须定义子类；2.子类一定要覆写抽象类或者接口中的全部抽象方法；3.通过子类的向上转型实现抽象类或接口对象实例化 ||


2. 当抽象类和接口都可以使用的时候，优先要考虑接口，因为接口可以避免子类的单继承局限
3. 另外从正常的设计角度而言，也需要先从接口来进行项目的整体设计
4. 各个结构的设计关系(见图片)
    * 先细分接口
    * 抽象类
    * 子类
    * 对象
5. 看见接口现阶段，先考虑从接口创建子类




# 做测试题


1. 访问权限降级依次如下：

    1. public：可以被所有其他类所访问
    2. protected：自身、子类及同一个包中类可以访问
    3. default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly
    4. private：只能被自己访问和修改
2. 解析：可以修饰类的修饰符有public，staic，final和abstract。private不能做类的修饰符。


# 21.综合案例：抽象类与接口应用
## 案例分析一（获取类信息）03:43

## 案例分析二（绘图处理）16:40
1. 画图接口
2. 多个图形子类继承画图接口
3. 工厂类，用来返回图形子类对象
4. 客户端使用多参数 ...
## 案例分析三（图形）09:12
1. 用抽象类
```java
abstract class AbstractShape {
    public abstract double area();
    public abstract double perimeter();
}
```
2. 抽象类也可以用工厂类
    * 抽象工厂设计模式
    * 返回对象
    * 客户端使用多参数 ...

3. 使用工厂设计模式完全隐藏了实现的子类

# 22.泛型
1. 泛型是从Jdk1.5之后寄到Java语言里面的，其主要目的是为了解决ClassCastException的问题，在进行对象的向下转型时，永远都可能勋在安全隐患，而Java希望可以通过泛型可以慢慢解决掉此类问题
## 泛型问题引出09:32
1. 假设说定义一个描述x,y坐标的处理类，并且在这个类中允许开发者保存三类数据
    * 整型数据：x=10、y=20
    * 浮点型数据：x = 10.1、y=20.9
    * 字符串型数据：x=东经120度、北纬30度
2. 于是在设计Ponint类的时候就需要去考虑具体的x和y属性的类型，这个类型要求可以保存以上三种数据
     * 最明显的就是使用Object类来定义
     * 因为存在有如下转型关系
        * 整型数据： 基本数据类型-->包装为Integer类对象-->自动向上转型为Object
        * 浮点型数据:基本数据类型-->包装为Double类对象-->自动向上转型为Object
        * 字符串性数据: 基本数据类型-->自动向上转型为Object
    ```java
    class Point{
        private Object x;
        private Object y;
        ...
    }
    ...
    Point point =new point;
    ```
3. 本程序之所以可以解决当前的设计问题，主要的原因在于，Object可以接收所有的数据类型，但也会出现严重的错误
    * 编译的时候不会出错，运行的时候可能会出现ClassCastException
        * 出错的情况是 设置的字符串类型，但是转型的是其他类型

## 泛型基本定义10:24
1. 避免出现ClassCastException的最好的做法就是避免强制转换
2. 泛型的本质：类中的属性或方法的参数与返回值的类型可以由对象实例化的时候动态决定
3. 那么此时就需要在类定义的时候明确的定义占位符(泛型标记)
    * Point<T> // T是Type的简写，可以定义多个泛型

    ```java
    //定义
    class Point<T> {

    }
    //使用
    Point<Integer> point = new Point<Integer>()
    // 不用向下强制转换
    ```

4. 这样，如果编码错误，编译的时候就会有错误提示
5. 泛型的使用注意事项
    * 泛型之中只允许设置引用类型，如果要操作基本类型，必须使用包装类
    * 从JDK1.7开始，泛型对象实例化可以简化为“Ponit <Integer> point = new Point<>()”

6. 使用泛型可以解决大部分的类对象的强制转换问题，这样的程序才是一个合理的设计
## 泛型通配符16:00
1. 泛型带来的问题：引用传递处理
2. 在一个方法中，接收的参数，是固定的泛型类型参数
    * 这是不合理的，如果真的使用泛型，方法应该可以接收任意种泛型类型的Message对象

3. 一个办法是将方法中的参数修改
    ```java
    public static void fun(Message<String> temp){

    } 
    // 修改为
    public static void fun(Message temp){

    }
    // 这样做的问题在于
    //在fun方法中调用setter
    temp.setContent()
    // 如果设置的类型与定义的不一样，就会有问题
    ```
4. 如果不设置泛型，那么在方法之中就有可能对你的数据进行修改
5. 使用通配符Message<?> 可以接收所有的类型，并且不允许修改，只允许获取数据
6. 在？通配符的基础之上，还提供了两类小的通配符
    * ？extends 类: 设置泛型的上限
        * ？extends Number 表示该泛型类型只允许设置Numbre或者Number的子类
    * ？super 类：设置泛型的下限
        * ？super String 表示只能够使用String或其父类

## 泛型接口03:56
1. 泛型除了可以在类上定义之外，也可以直接在接口之中进行使用，例如：下面定义一个泛型接口
    ```java
    interface IMessage<T> {
        public String echo(T t);
    }
    //对于泛型接口的子类而言，现在就有两种实现方式了
    //1. 在子类之中继续设置泛型定义

    class MessageImpl<S> implements IMessage<S> {
        public String echo(S t) {
            return "【ECHO】" + t;
        }
    }
    //使用
    IMessage<String> msg = new MessageImpl<String>();
    // 2. 在子类实现父接口的时候，直接定义出具体的泛型类型
    class MessageImpl implements IMessage<String> {
        public String echo(String  t) {
            return "【ECHO】" + t;
        }
    }
    //使用
    IMessage<String> msg = new MessageImpl();
    ```

## 泛型方法12:12
1. 常见的
    ```java
    public static <T> T[] fun(T ... args){
        return args;
    }
    // 使用
    Integer num[] = fun(1,2,3);
    for (int i:num){
        System.out.print(i+"、")
    }
    ```
2. 优化工厂类
    * 如果一个项目有上千个接口
    ```java
    public static <T> T getInstance (String className,T t) {
        if ("messageImpl".equalsIgnoreCase(className)){
            return new MessageImpl();
        }
        return null;
    }
    ```

# 23.包的定义及使用
## 包的定义07:47
```java
package cn.mldn.demo;
public class Hello {

}
```
1. javac -d . JavaDemo.java
    * -d 表示要生成目录，而目录的结构就是package定义的结构
    * . 表示在当前所在目录中生成程序类文件

2. 执行的时候一定要带着包执行程序类 
    * java cn.mldn.demo.Hello

## 包的导入17:45
1. 在同一个文件下编写了几个java文件
1. 编译命令
    * javac -d . *.java
2. public class 和class 定义的区别
    * 在实际开发中往往在一个*.java源代码文件里面只会提供有一个程序类，而这个程序类一般都使用public class 定义 
    * public class 类名称必须与文件名称保持一致，一个*.文件里面只允许有一个public class，如果一个类需要被其他的包所使用，那么这个类一定要定义为 public class 
    * class 类名称可以与文件名称不一致，并且在一个源文件中可以提供多个class定义，编译后将形成不同的*.class文件，但是这些类只能够被本包所访问，外包无法访问
3. 包.*  而且最终的性能是完全相同的
4. 可能会出现相同的类名称
    * 使用的时候 cn.mldn.utils.Message msg
    * 如果只用其中一个，可以在源文件的头部显示的引入类名  

## 静态导入05:40
1. 一个类中的方法全部都是静态的
    * 1.5之后 
    * import static cn.mldn.util.MyMath.*
    * 使用的时候，不用在加类名
        * add(10,20)
2. 讲师说，这样很不方便，不知道为什么 
## 生成jar文件16:17
1. 将大量的*.class文件，利用一种叫做压缩结构的形式管理
2. 利用jdk中提供的jar命令完成
3. 在原始的时候要想知道ja命令的时候直接输入jar即可，而在JDK1.9之后嗯，为了统一化，需要使用'--help' 查看相关的说明
4. jar的使用与配置操作
    1. 定义一个程序类
    2. 对程序进行编译与打包处理
        * 打包编译：javac -d . Message.java
        * jar -cvf mldn.jar cn
            * -c 创建一个新的jar文件
            * -v 得到详细输出
            * -f 设置要生成的jar文件的名称 mldn.jar
            * 我们的包的文件夹是cn
    3. 使用
        1. 删掉编译后的文件，继续编译，无法编译
        2. 通过classpath进行配置
        3. SET CLASSPATH=.;D:\mldndemo\mldn.jar
        4. 随后就可以正常编译TestMessage类并使用
            * javac -d . TestMessage.java
            * java cn.mldn.test.TestMessage
5. 1.9之后的模块化设计


## 系统常用包06:58
1. java.lang 向String、Number、Object 都在这，在1.1之后，是自动导入的
2. java.lang.reflect: 反射机制处理包，所有的设计从此开始
3. java.util：工具类的定义，数据结构的定义
4. java.io : 进行输入与输出流的操作
5. java.net : 网络程序开发的程序包
6. java.sql : 进行数据库编程的开发包
7. java.applet :Java最原始的使用形式直接嵌套在网页上执行的程序类
    * 现在的程序已经已Application为主了(有主方法的类)
8. java.awt/java.swing : java的图形界面开发包(GUI),awt是重量级。swing是轻量级
## 访问控制权限10:07
0. private、default(不写)、protected、public
1. 同一包中的同一类  都可以
2. 同一包中的不同类  default(不写)、protected、public
3. 不同包的子类      protected、public
4. 不同包的所有类    public
# 24.UML图形

## 类图21:06
1. 分3层
    * 类名称
    * 属性  访问权限 属性名称 ：属性类型
        public(+) protected(#) private(-)

    * 方法 访问权限 方法名称 ：返回值

## 时序图06:20
1. 流程的图形描述
    * 类的调用的次序
## 用例图03:23
1. 程序的执行分配

# 25.单例设计模式

## 单例设计17:53
1. 要求Singleton这个类只允许提供有一个实例化对象，那么此时首先应该控制的就是构造方法。
2. 构造方法私有化
    * 声明时没问题的
    * new的时候出错了 
3. 现在是有要求的，必须产生有一个实例化对象
    1. private访问权限的主要特点是，不能再类外部访问
        * 在内部实例化好
        `private Singleton instance = new Singleton();`

    2. 此时Singleton类内部的instance属于一个普通属性，而普通属性是在有实例化对象产生之后才会被调用的，这个时候，外部无法产生实例化对象，所以这个属性久不能访问到了，那么久必须考虑如何在没有实例化对象的时候获取此属性，
        `private static Singleton instance = new Singleton()`
    3. 类中的属性应该封装后使用，所以理论上此时的instance需要被封装起来，那么就需要通过一个static方法获得
        `public static Singleton getInstance(){return instance}`

4. 这个时候虽然提供了static的实例化对象，但是，还是有可能有新的实例化对象，所以需要保证此时Singleton类内部的instance无法再次实例化，那么应该使用final定义
    `private static final Singleton INSTANCE = new Singleton()`

5. 为什么要强调单例
    * 例如 程序的加载信息类，不需要产生很多个
    * win下的回收站
6. 单例模式的分类   
    * 懒汉式  在第一次使用的时候进行实例化对象处理
    * 饿汉式
7. 修改为懒汉式
    ```java
    private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
8. 请编写一个Singleton程序，并说明其主要特点
    1. 代码如上，可以把懒汉式(后面需要考虑到线程同步问题)和饿汉式都写上
    2. 特点: 构造方法私有化，类内部提供static方法获取实例化对象，这样不管外部如何操作，永远都只有一个实例化对象提供

## 多例设计04:33
1. 例如：描述性别的类，那么该对象只有两个:男、女
```java
class Color {
    private static final Color RED = new Color("红色");
    private static final Color GREEN = new Color("绿色");
    private static final Color BLUE = new Color("蓝色");
    private String title;
    private Color(String title) {
        this.title = title;
    }
    public static Color getInstance(String color) {
        switch(color) {
            case "red": return RED;
            ...
        }
    }
}
```
2. 多例设计与单例设计的本质是相同的，一定会在内部提供有static方法以返回实例化对象
# 26.枚举
## 定义枚举类09:45
1. 主要作用是用于定义有限个数对象的一种结构(多例设计)，枚举就属于多例设计
2. enum
`enum Color {RED,GREEN,BLUE}`
`Color c = Color.RED`
3. 1.5之后，枚举与swich
    * 可以直接使用swich

## Enum类05:07
1. 枚举默认继承Enum类
2. 查看枚举类的结构
    * 泛型 上限
3. color.values
4. enum和Enum的区别
    * enum 是从JDK1.5之后提供的一个关键字，用于定义枚举类
    * Enum 是一个抽象类，所以使用enum关键字定义的类就默认继承了此类
## 定义枚举结构07:19
1. 枚举类中不能采用非私有化(public无法使用)
2. 枚举对象要写在第一行
3. 枚举类直接定义抽象方法，并且每一个枚举对象都要独立覆写此抽象方法
4. 枚举的正确用法是定义一个实例范围

## 枚举应用案例02:45
1. 
```java
enum Sex {
    MALE("男"),FEMALE("女");
    private String title; 
    private Sex(String title){
        this.title = title;
    }
    public String toString(){
        return this.title;
    }
}
class Person {

}
```
# 27.异常的捕获及处理
## 认识异常对程序的影响06:23

## 处理异常06:57
1. 异常的处理 ： try、catch、finally这几个关键字
```java
try {

} catch (ArithmeticException e) {
    e.printStackTrace()
} finally {
    //不管出现不出现异常，都执行
}
```
2. 获取完整的异常信息,
    * 使用 printStackTrace()方法
## 处理多个异常07:04
## 异常处理流程14:23
1. Throwable
    * Error 此时程序还未执行出现的错误，开发者无法处理
    * Exception 程序中出现的异常，开发者可以处理，真正在开发之中所需要关注的就是Exception
2. 要把捕获范围大的异常放在范围小的异常后面

## throws关键字08:58
1. throws 关键字来进行异常类型的标注
2. 标注之后，要处理
2. throws的使用
```java
class MyMath {
    public static int div(int x,int y) throws Exception {
        return x/y;
    }
}
public class JavaDemo {
    public static void main(String args[]) {
        try {
            System.out.println(MyMath.div(10,2));
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
3. 主方法也可以继续向上抛出
    * 在main方法上使用throws之后，就不用处理了
    * 交给了JVM
## throw关键字03:28
1. 手工进行异常的抛出，即：此时将手工产生一个异常类的实例化对象，并且进行异常的抛出处理
2. throw的使用
```java
try{
    throw new Exception("自己抛着玩的对象")
}catch(Exception e){
    e.printStackTrace();
    
}
```
3. 请解释throw和throws的区别
    * throw ：在代码块上使用的，主要是手工进行异常对象的抛出
    * throws ：是在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处，由调用处进行处理


## 异常处理模型06:53
```java
class MyMath {
    public static int div (int x,int y) throws Exception {
        int temp = 0;
        System.out.println("开始计算")
        try {
            temp = x/y;
        //}catch (Exception e){
        //    throw e  // 向上抛
        }finally {
            System.out.println("结束计算")
        }
        return temp
    }
}

public class JavaDemo {
    public static void main (String args []){
        try {
            System.out.println(MathMath.div(10,0));
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```
1. 对于此类操作实际上可以简化，省略掉catch与throw的操作
    * 不处理异常了，直接交给了throws
    * 这就是try{}finally{}的用法
2. 
## RuntimeException07:30
1. 没有强制处理的异常，就是throws了的异常，但是并没有处理方，
2. RuntimeException 这个类的异常的子类可以不需要强制处理

3. 请解释RuntimeException和Exception的区别
    * RuntimeException 是 Exception的子类
    * RuntimeException 标注的异常可以不需要进行处理
    * Exception异常必须强制性处理
4. 请列出几个你常见的额RuntimException
    * 
    *
    * 前面基本上都在和RuntimeException折腾

## 自定义异常类04:33
1. 吃饱了的异常
2. 继承 RuntimeException或者Exception
3. 范例
    * 继承
    * 构造方法 一个参数，提示的消息的参数
    * super(msg)
    * 调用 throw new 类名("吃太多，要炸了")
4. 解决异常最快的方法，搜索引擎

## assert断言05:00
1. 确定代码执行到某行之后，一定是所期待的结果
2. 要想执行断言，则必须在程序执行的时候加入参数
    * java -ea JavaDemo
    * 会出现一个错误
    * 所以在java里面并没有将断言设置为一个程序必须执行的步骤，需要特定环境下才可以开启
3. 断言表示程序写错了，只要发生断言（更正：此处应为断言失败），意味着至少有一个人得修改代码。它的性质如同编译错误。（来自知乎）
# 28.内部类
## 内部类基本概念09:46
1. 从整体的代码结构上来讲，内部类的结构并不合理，所以内部类本身最大的缺陷在于破坏了程序的结构，但是 破坏需要有目的的破坏
2. 那么他的好处是，优势是？
    * 如果想更好的观察出内部类的优势，就可以将内部拿到外部
    * 连个独立的类之间要相互调用对方的方法。做很多引用，很麻烦
3. 内部类的优点:轻松的访问外部类的私有属性
## 内部类相关说明17:13
1. 外部类，也可以轻松访问内部类的私有属性或者方法
2. 内部与外部之间私有操作的访问就不在需要通过setter，getter以及其他间接方式完成了，直接进行处理操作

3. 需要注意的是，内部类本身也是一个类
    * 而此时内部类实例化对象的格式如下：
        `外部类.内部类 内部类对象 = new 外部类().new 内部类();`
    * 实例化内部类,要先保证外部类首先实例化
4. 编译之后 Outer$Inter.class
5. 在Java之中类作为最基础的结构体实际上还有一只类似的抽象类或者接口
    * 抽象类与接口都可以定义内部接口
    * 范例：接口内 内部接口
    * 内部接口不是必须实现
6. 下面继续观察一个内部的抽象类，内部抽象类可以定义在普通类、抽象类、接口内部

7. 范例：内部抽象类
8. 内部类还有一些更为有意思的结构
    * 即：如果现在定义了一个接口，那么可以在内部利用类实现该接口
    * 在1.8之后，接口追加了static方法，可以不收到实例化对象的控制，现在就可以利用此特性来完成功能
9. 范例：接口内部进行接口实现


## static定义内部类09:09
1. 内部类使用了static定义，那么这个内部类就编程了“外部类”
2. static 定义的都是独立于类的结构，所以该类结构 就相当于是一个独立的程序类 
3. static定义的不管是类还是方法，都只能够访问static成员
    * 实例化Outer.inner 对象 = new Outer.inner()

4. static 定义内部类的形式并不常用，static定义内部接口的形式最常用
5. 范例： 定义了一组收发消息的接口
6. 之所以使用static定义的内部接口，主要是因为这些接口是属于一组相关的定义，有了外部接口之后，可以更加清楚的描述这些接口的主要功能
```java
interface IMessageWrap {
    static interface IMessage {
        public String getContent()
    }

    static interface IChannel {
        public boolean connect()  //发送通道
    }

    pubic static void send(IMessage msg,ICannel, channel) {
        if (channel.connect()){

        }else{

        }
    }
}
```
## 方法中定义内部类04:41
1. 内部类可以在任意的结构中定义，包括了:类中、方法中、代码块中
2. 从设计开发来看，在方法中定义的内部类较多

3. 内部类 对于方法中的参数直接访问是从JDK1.8开始支持的
    * 1.8之前要访问的话，方法的参数之前必须要追加final
    fun(final long time)
        final String info = "我很好"

4. 之所以取消这样的限制，主要是为了其扩展的函数式编程准备的功能。

## 匿名内部类05:50

1. 主要在抽象类和接口的子类上使用
2. 只是用一次
```java
interface IMessage {
    public void send(String str)
}
...
IMessage msg =  new Message(){
    ... 
}
```
3. 有时候为了更加方便的体现匿名内部类的使用，往往可以利用静态方法做一个内部的匿名内部类实现
```java
interface IMessage {
    public void send(String str)
    public static IMessge getInstance(){
        return new IMessage(){
            ...
        }
    }
}
```
# 29.函数式编程
## Lamda表达式13:21
1. ()->{}
2. Lambda表达式如果想要使用，那么必须要有一个重要的实现要求：SAM（Single Abstract Method）只有一个抽象方法
3. 只提供一个send()方法的接口，叫做函数式接口，而只有函数式接口才可以被Lambda表达式所使用
    * 函数式接口可以加注解@FunctionalInterface
4. Lambda的几种格式
    * 方法没有参数 ()->{}
    * 方法有参数  (参数，参数)->{}
    * 如果只有一行语句返回 (参数，参数)-> 语句

```java
interface IMessage {
    public void send(String str);
}

public class JavaDemo {
    public static void main(String args[]) {
        IMessage msg = (str)->{
            System.out.println(str)
        }

        msg.send("Hello")
    }
}
```
## 方法引用14:00
1. 引用数据类型最大的特点是可以进行内存的指向处理
2. 但是在传统的开发之中一直所使用的只是对象引用操作，而JDK1.8之后，开始提供方法引用，即不同的方法名称可以描述同一个方法
    * 引用静态方法 类名称::static 方法名称
    * 引用某个实例对象的方法 实例化对象::普通方法
    * 引用特定类型的方法 特定类 :: 普通方法
    * 引用构造方法 类方法 :: new

3. 小插曲，中文也能做方法名
4. 范例:引用静态方法
    ```java
    //在String里面提供的String.valueOf()方法，这个方法就是静态方法
    //方法有参数，有返回值
    public static String valueOf(int i)
    // 范例
    @functionalInterface
    interface IFunction<P,R>{ //P:参数 R:返回值
        public R change(P p);
    }

    public class JavaDemo {
        public void main(String args[]) {
            IFunction<Integer,String> fun = String ::valueOf;
            String str = fun.change(100);
            System.out.println(str.length()); 
        }
    }
    ```
    * 利用方法应用这一概念可以为一个方法定义多个名字，但是要求必须是函数式接口

5. 范例：引用实例化对象中的方法
    ```java
    //String里面有一个转大写的方法 
    public String toUpperCase();
    // 这个方法必须在有实例化对象提供的时候才能调用
    @functionalInterface
    interface IFunction<R>{ //R:返回值
        public R upper();
    }

    public class JavaDemo {
        public void main(String args[]) {
            IFunction<String> fun = "www" ::toUpperCase;
            System.out.println(fun.upper()); 
        }
    }

    ```
6. 范例：引用特定类中的一些操作
    ```java
    //在String里面有一个字符串大小写关系的比较
    public int compareTo(String anotherString);
    //这是一个普通方法，如果要引用普通方法，则往往需要实例化对象，但是现在不给实例化对象，只是想引用这个方法
    //则就需要使用特定类来进行引用处理
    @functionalInterface
    interface IFunction<P>{ 
        public int compare(P p1,P p2); 
    } 

    public class JavaDemo {
        public void main(String args[]) {
            IFunction<String> fun = String ::compareTo;
            System.out.println(fun.compare("A","a"));
        }
    }

    ```
7. 范例: 引用构造方法
    ```java
    class Person {
        private String name;
        private int age;
        public Person(String name,int age) {
            this.name = nane;
            this.age = age;
        }

        public String toString(){
            return "Info："+this.name + this.age
        }

    }
    @functionalInterface
    interface IFunction<R>{ 
        public R compare(String s,int a); 
    } 

    public class JavaDemo {
        public void main(String args[]) {
            IFunction<Person> fun = Person ::new ;
            System.out.println(fun.compare("张三", 20 ));
        }
    }
    ```
8. 提供方法引用的概念更多的情况下也只是弥补了对于引用的支持功能

## 内建函数式接口13:02
1. 由开发者自己定义函数式接口，往往都需要使用大量的定义形式
    * 使用@functionalInterface 注解来进行大量声明，于是很多情况下如果为了方便，则可以直接引用系统中提供的函数式接口
2. java.util.function 开发包中提供了可以直接使用的函数式接口
3. 几个核心接口
    * 功能性函数式接口
        * 接口定义
        ```java
            @FunctionalInterface
            public interface Function<T,R>{
                public R apply(T t);
            }
        ```
        * 接口使用
        ```java
            import java.util.function.*;
            public class JavaDemo {
                public static void main(String args[]){
                    Function<String,Boolean> fun = "**Hello" :: startsWith;
                    System.out.println(fun.apply("**"))
                }
            }
            // 没必要再单独建接口了
        ```
    * 消费型函数式接口:只能够进行数据的处理操作，而没有任何的返回
        * 如 System.out.println()
        * 接口定义
        ```java
            @FunctionalInterface
            public interface Consumer<T> {
                public void accept​(T t)
            }
        ```
        * 接口使用
        ```java
            import java.util.function.*;
            public class JavaDemo {
                public static void main(String args[]){
                    Consumer<String > con = System.out :: println;
                    con.accept("www")
                }
            }
            // 没必要再单独建接口了
        ```
    * 供给型函数式接口：
        * 在String中提供有转小写方法，这个方法没有接受参数，但是有返回值
            * public String toLower();
        * 接口定义
        ```java
        @FunctionalInterface
        public interface Supplier<T> {
            public T get()
        }
        ```
        * 接口使用
        ```java
            import java.util.function.*;
            public class JavaDemo {
                public static void main(String args[]){
                    Supplier<String > sup = "WWW" :: toLowerCase;
                    System.out.println(sup.get());
                }
            }
            // 没必要再单独建接口了
        ```
    * 断言型函数式接口：
        * 进行判断处理
        * 在String类有一个equalsIgnoreCase()方法 
        ```java
        @FunctionalInterface
        public interface Predicate<T> {
            public boolean test​(T t);
        }
        ```
        * 接口使用
        ```java
            import java.util.function.*;
            public class JavaDemo {
                public static void main(String args[]){
                    Predicate<String > pre = "WWW" :: equalsIgnoreCase;
                    System.out.println(pre.test("www "));
                }
            }
            // 没必要再单独建接口了
        ```
# 30.链表的定义与使用
## 链表实现简介23:24
1. 对象数组，我们利用其可以描述“多”方面的信息 例如，一个人有多本书
2. 但是传统的对象数组依赖于数组的概念
3. 数组最大的缺点是长度固定
4. 传统的数组应用是非常有限的(数组的接收以及循环处理)，要进行灵活的数据保存，那么就要自己来实现结构
5. 传统的数组依赖脚标(索引)
6. 链表的实质是利用引用的逻辑关系来实现类似于数组的数据处理操作
7. 需要一个公共结构，要用泛型


## 数据增加14:47
1. 链表接口
2. 链表类
    * 节点对象（这样链表类就不用在写setter和getter）
    * 增加的方法
```java
interface ILink<E>{  //设置泛型避免安全隐患
    public void add(E e);
}

class LinkImpl<E> implements ILink<E> {
    private class Node {  //保存节点的数据关系
        private E data;  //保存的数据
        private Node next;  // 保存下一个引用
        public Node(E data) {  //有数据的情况下才有意义
            this.data = data;
        }
        // 第一次调用 : this = LinkImpl.root;
        // 第二次调用 ：this = LinkImpl.root.next;
        // 第三次调用 ：this = LinkImpl.root.next.next;

        public void addNode(Node newNode) { //保存新的Node数据
            if(this.next == null){
                this.next = newNode;
            }else{
                this.next.addNode(newNode);
            }
        }
    }
    // ------Link类定义的成员
    private Node root ; //根节点
    // ------Link类中定义的方法
    public void add(E e) {  //保存的数据为null
        if (e==null){  //保存的数据为null 
            return; //方法调用直接结束
        }
        // 数据本身是不具有关联特性的，只有Node类有
        Node newNode = new Node(e); //创建新的节点
        if (this.root == null) { // 现在没有根节点
            this.root = newNode;  // 第一个节点作为根节点
        }else{  // 有根节点
            this.root.addNode(newNode);
        }
    }
}

// 用户调用
public class LinkDemo {
    pblic static void main(String args[]) {
        ILink<String> all = new LinkImpl<String>();
        all.add("Hello");
        all.add("World");
        all.add("Peter");
    }
}
```
## 获取集合个数03:11
1. public int size()
2. 接口增加函数 
`public int size()` ;
3. 在LinkImpl中添加
```java
private int count; // 保存数据个数

this.count ++; // ，在add里面进行追加

public int size(){
    return this.count;  // 返回数量
}
//客户端调用
all.size()
```
## 空集合判断02:16
0. public boolean isEmpty()
1. 使用count 和 根节点的本质是一样的
## 返回集合数据11:03
0. public Object[] toArray()
1. 添加
```java
// 接口中添加
public Object[] toArray();  //将元素以数组的形式返回
// LinkImpl子类里面追加
private foot; //描述的的是操作数组的脚标
private Object [] returnData;  //返回的数据
// 在进行数据返回的时候，一定要先判断数据是否为空
public Object[] toArray(){
    if (this.isEmpty()) {
        return null; // 没有数据，返回空
    }
    this.foot = 0; //脚标清零
    this.returnData = new Object [this.count];  
    // 利用Node类进行递归数据获取
    this.root.toArrayNode()
    return this.returnData
}
// 在Node类中递归获取数据
public void toArrayNode(){
    LinkImpl.this.returnData [LinkImpl.this.foot ++] = this.data;
    if (this.next != null) { //还有下一个数据
        this.next.toArrayNode();
    }
}

```

## 根据索引取得数据07:51
1. 在ILink里面追加新的方法
`public E get(int index) // 根据索引获取数据`
2. 在LinkImpl子类里面定义数据获取的实现
```java
public E get(int index) {
    if (index >= this.count) { //索引应该在指定的范围之内
        return null;
    }// 索引数据的获取 应该有Node类完成
    this.foot = 0;
    return this.root.getNode(index) ;
}
```
3. 在Node类中追加有根据索引获取数据的处理
```java
public E getNode(int index){
    if (LinkImpl.this.foot ++ == ndex) { // 索引相同
        return this.data;
    } else {
        return this.next.getNode(index);
    }
}
```
4. 数组获取一个数据的时间复杂度为1，链表获取数据的时间复杂度为n
## 链表（修改指定索引数据）03:43
1. ILink添加方法
`public void set(int index,E data);// 修改索引数据` 

2. 在Node类之中应该提供有数据修改的处理支持
```java
public void setNode(int index,E data){
    if (LinkImpl.this.foot ++ == ndex) { // 索引相同
        this.data == data;  //修改数据
    } else {
        this.next.getNode(index,data);
    }
}
```
3. 在LinkImpl子类里面进行方法的覆写
```java
public E set(int index) {
    if (index >= this.count) { //索引应该在指定的范围之内
        return; // 方法结束
    }// 索引数据的获取 应该有Node类完成
    this.foot = 0;
    this.root.setNode(index,data) ; //修改数据
}
```


## 链表（判断数据是否存在）04:26
0. 通过equals()方法来完成判断
1. ILink接口类中添加方法
`public boolean contains(E data);`
2. 在Node类中依次判断
```java
public boolean containsNode (E data) {
    if (this.data.equal(data)){
        return true;
    }else{
        if (this.next == null){ //没有后续节点
            return false; 
        }else {
            return this.next.containsNode(E data);
        }
    }
}
```
3. 在LinkImpl子类是实现方法
```java
public boolean contains (E data){
    if (data == null){
        return false; //
    }
    return this.root.containsNode(data);//交给Node 类判断
}
```
4. null的判断
    * 之前已经做了对null数据的限制
        * 整个数据没有空数据
        * 所以在整体程序判断的时候直接使用每一个节点数据发出equals()
    * 如果有空数据，要将data放在前面

## 链表（数据删除）11:58
0. 删除指定内容
    * 要删除的是根节点数据
        * LinkImpl与根节点有关，所以这个节点由根节点判断
    * 要删除的不是根节点
        * 由Node类负责
1. 接口类添加
`public void remove(E data);`

2. 依然需要对象比较的支持
3. 在Link'Impl子类里面实现根节点的判断
```java
public void remove(E data){
    if (this.contains(data)) { // 判断数据是否存在
        if (this.root.data.equals(data)) {
            // 根节点为要删除节点
            this.root = this.root.next; //根的下一个节点
        }else{
        //交给Node
            this.root.next.removeNode(this.root,data)
        }
        this.count --; //数量--

    }
}
```
4. 删除的不是根节点
    * 从根节点的下一个节点开始判断
    * 在Node类中追加删除处理
    ```java
    public removeNode(Node previous,E data) {
        if(this.data.equals(data)) {
            previous.next = this.next; // 空出当前节点
        }else {
            if (this.next != null ){ //有后续节点
                this.next.removeNode(this, data) ; //向后继续删除
            }
        }
    }
    ```
5. 完成LinkImpl子类中的remove方法
6. 删除的逻辑依靠的就是引用的改变来完成的

## 链表（清空链表）03:07

1. 只要将根元素root的的值设置为空，那么后续的节点就都不存在了
2. 在ILink接口类中追加清空处理方法
`public void clean(); //集合清空`

3. 在ILinkImple子类中覆写
```java
public void clean(){
    this.root = null; // 后续的节点都没有
    this.count = 0; // 个数清零
}
``` 

## 综合实战：宠物商店17:41
0. 现在有一个宠物商店，里面可以承受各种宠物，要求可以实现宠物的上架和下架，也可以根据关键字查询宠物的信息
1. 宠物商店 --- 链表接口 --- 宠物接口 --- 多个宠物
                  |            |
              链表实现类        
2. 定义宠物的标准
```java
interface Pet { //定义宠物标准
    public String getName();
    public String getColor();
}
```
3. 宠物商店
```java
class PetShop {
    private ILink<Pet> allPets = new ILinkImpl<Pet>();//保存多个宠物信息
    public void add(Pet pet) {
        this.allPets.add(pet);
    }
    //
    public void delete(Pet pet){
        this.allPets.remove(pet);
    } 
    //
    public ILink<Pet> void search(String keyword){
        ILink<Pet> searchResult = new LinkImpl<Pet>; //保存查询结果
        Object result [] = this.allPets.toArray();
        if (result != null) {
            for (Object obj :result) {
                Pet pet = (Pet) obj;
                if (pet.getName().contains(keyword) || pet.getColor().contains(keyword)) {
                    searchResult.add(pet) ; //保存查询结果
                }
            }
        }
        return searchResult;
    }
}
```
4. 根据宠物标准来定义宠物信息
```java
class Cat implements Pet {
    private String name;
    private String color;
    public Cat(String name,String color){
        this.name = name;
        this.color = color;
    }
    // setter getter 略 
    // equals--利用instanceof
    // toString
}
```

5. 实现宠物商店的操作

## 综合实战：超市购物车14:34
0. 使用面向对象表示出下面的生活场景(见图片)
    * 修改了场景，增加购物车的标准
1. 定义商品标准(接口)
2. 定义购物车标准
3. 实现购物车
4. 定义收银台类
    * 计算总价
    * 购物车
    * 商品数量
5. 定义商品信息
6. main函数，编写测试代码

# 31.Eclipse开发工具、
1. Eclipse 如果翻译为中文，实际上的含义是"日蚀"(遮盖一切的太阳光芒)
2. 下载Eclipse
    `www.eclipse.org`
    * java EE 版
3. 本身是绿色版本
4. 工作区，选择，不要打钩(默认使用本工作区)
5. 界面window-showview
    * 删掉重新建立
6. 支持JDT Junit CVS客户端、插件开发
    * EE 还支持Java EE的开发

## Eclipse简介24:07
1. 创建项目
2. 选择JRE 默认选择的是标准的JVM
    * JREhome jdk的目录 d:\jdk-9.0.01
3. 项目有多个JDK的时候，就必须使用这种方法进行配置
4. 创建完成
    * src 所有java源文件
    * bin 编译后的class文件
5. 建java文件
    * 包名
    * 文件名
    * 可选择的很多
6. 调整字体
    * Ctrl + 
7. 修改文件编码
    * 当前文件-右键-Properties  --最下面Other ：UTF-8
    * window-preferences(首选项)-搜索encoding-Workspace-也是在最下面修改
8. 保存之后自动编译，右键找到运行
9. 快捷键
    * Ctrl 1 进行代码纠正提示
    * Alt  / 进行代码提示
    * ctrl shift ↓   复制当前行
    * ctrl / 单行注释
    * ctrl shift / 多行注释
    * ctrl shift F 格式化代码
    * ctrl shift O 自动导入所需要的包
    * 如果觉得以上的快捷键不够用，可以自行查阅 ctrl shift L
10. 在 Eclipse 里面还支持代码生成的操作
    * 写好了类名和属性
    * source - Generate
11. 由用户方便的进行异常的处理

12. 在程序执行的时候可以使用初始化参数进行内容的接收
    * 需要先执行一次，才可以配置
    * 右键run as --run configrations
    * 执行一次后 才会出现我们需要设置的
    * 选中-- Arguments

13. 使用Eclipse还可以直接将类导出为*.jar文件
    * File --Export-- Java-jar


14. 导入其他的jar文件
    * 需要针对某一个项目进行配置，使用Java构建路径进行定义
    * 项目右键--Java Build Path -- Libraries -- Classpath-- Add Extendal Jars --选择


## 使用JDT开发Java程序30:22

## 代码调试11:47
1.  设置断点
2. 右键debug as
3. 调试的几个控制工具
    * 和pycharm的一样
    * F5 单步跳入
    * F6 单步跳过
    * F7 单步返回
    * F8 恢复执行，取消断点的影响
4. 太麻烦了，我喜欢加点输出自己观察
## junit测试工具07:
0. junit 是一个第三方的组件包
    * 需要在项目之中配置相应的jar文件
    * 所以建议可以直接通过Eclipse配置，选择要测试的类
    * 选中-- 点击新建 -- 输入 junit
        * 有两个选项 suite（一组用例） 和case（一个用例）
        * 输入包名
        * 选择要测试的方法
1. junit是第三方的包，所以需要在JavaBuilderPath中配置相应的程序库，使用此种方法的主要原因是他可以帮助我们开发者自己来配置*.jar文件CLASSPATH环境
     
2. 编写
3. 由于此时是一个junit测试程序类，所以可以利用junit的方式执行
    * 右键 run as

4. 

1. 定义一个专门用来测试的处理类
2. 